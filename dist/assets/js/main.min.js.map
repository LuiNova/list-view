{"version":3,"sources":["app.js","main.js","components/infinite-scroller-experimental.js","components/infinite-scroller-v2.js","components/infinite-scroller.js","datasource/messages.js"],"names":["requirejs","config","baseUrl","paths","app","main","init","define","InfiniteScroller","InfiniteScrollerExperimental","Messages","scroller","document","querySelector","scrollerExp","messagesSource","url","dataEndpoint","this","infiniteScroller","swipeable","infiniteScrollerExp","dataSource","options","_classCallCheck","itemsCacheData","loadingItemHeight","loadingItemWidth","loadingItems","physicalItems","firstPhysicalItemIndex","middlePhysicalItemIndex","lastPhysicalItemIndex","firstPhysicalItem","lastPhysicalItem","firstPhysicalItemTranslateY","lastPhysicalItemTranslateY","requestInProgress","target","targetBCR","targetX","startX","currentX","translateX","draggingItem","anchorItem","createElement","anchorItemHeight","style","position","height","width","appendChild","scrollRunway","scrollRunwayEndBefore","scrollRunwayEnd","transition","previousScrollTop","addEventListeners","count","onResize","loadItems","_createClass","key","value","_this","window","addEventListener","e","onScroll","onTouchStart","onTouchMove","onTouchEnd","loadingItem","createLoadingElement","offsetHeight","offsetWidth","removeChild","delta","scrollTop","normalizedLastItemIndex","proximityToLastPhysicalItem","dataset","translateY","normalizeFirstItemIndex","itemsSpace","approximateEmptySpace","proximityToFirstPhysicalItem","loadItemsUp","_this2","loadingHeight","i","hasLoadingItem","transform","classList","remove","nextIndexToPopulate","populateItems","slice","next","then","response","items","fromCache","currentCacheDataLength","length","add","itemIndex","hasReusableItem","item","render","calculatePhysicalItemsIndex","loadingItemTranslateY","populateItemsTop","itemBeforeFirstPhysicalItemIndex","reusableItemIndex","console","log","hasItem","itemsLength","Math","max","parseInt","_this3","contains","getBoundingClientRect","touches","pageX","willChange","requestAnimationFrame","update","threshold","abs","_this4","normalizedDragDistance","opacity","pow","isNearlyAtStart","parentNode","targetIndex","virtualItems","indexOf","splice","animateOtherItemsIntoPosition","resetTarget","startIndex","_this5","onAnimationComplete","removeEventListener","_","anchorScrollTop","firstAttachedItem","lastAttachedItem","virtualItemsCount","physicalItemsCount","loadedItems","loadItemsExp","firstLoad","firstLoadItems","concat","populateItemsExp","push","scrollBoundary","scrollHeight","start","end","attachContent","pop","data","node","addItem","_this6","itemsData","loadingTemplate","messageTemplate","dataUrl","nextItem","nextPageToken","obj","limit","Promise","resolve","reject","params","_typeof","Object","keys","map","encodeURIComponent","join","xhr","XMLHttpRequest","open","method","onload","status","statusText","onerror","send","pageToken","fetch","jsonResponse","JSON","parse","messages","cloneNode","div","id","src","author","photoUrl","textContent","name","timeSince","Date","updated","content","date","seconds","floor","interval"],"mappings":"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","file":"main.min.js","sourcesContent":["// For any third party dependencies, like jQuery, place them in the lib folder.\n\n// Configure loading modules from the lib directory,\n// except for 'app' ones, which are in a sibling\n// directory.\nrequirejs.config({\n    baseUrl: 'src/javascript',\n    paths: {\n        app: '../dist'\n    }\n});\n\n// Start loading the main app file. Put all of\n// your application logic in there.\nrequirejs(['main'], function(main) {\n    main.init();\n});","define('main', [\n    'components/infinite-scroller',\n    'components/infinite-scroller-experimental',\n    'datasource/messages'\n], function(\n    InfiniteScroller,\n    InfiniteScrollerExperimental,\n    Messages\n) {\n    'use strict';\n    \n    return {\n        init: function() {\n            const scroller = document.querySelector('#messages');\n            const scrollerExp = document.querySelector('#messages-exp');\n            const messagesSource = new Messages({\n                url: 'http://message-list.appspot.com',\n                dataEndpoint: '/messages'\n            });\n\n            if (scroller) {\n                this.infiniteScroller = new InfiniteScroller(scroller, messagesSource, {\n                    swipeable: true\n                });\n            }\n\n            if (scrollerExp) {\n                this.infiniteScrollerExp = new InfiniteScrollerExperimental(scrollerExp, messagesSource, {\n                    swipeable: true\n                });\n            }\n        }\n    };\n});","define('components/infinite-scroller-experimental',[\n], function() {\n    'use strict';\n    \n    const PHYSICAL_ITEMS = 20;\n    const PAGE_SIZE = 10;\n    const PROXIMITY_BOUNDARY = 300;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n            \n            // This will hold a cache of the data sent from server\n            this.itemsCacheData = [];\n\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.physicalItems = [];\n            this.firstPhysicalItemIndex = -1;\n            this.middlePhysicalItemIndex = -1;\n            this.lastPhysicalItemIndex = -1;\n            this.firstPhysicalItem = null;\n            this.lastPhysicalItem = null;\n            this.firstPhysicalItemTranslateY = 0;\n            this.lastPhysicalItemTranslateY = 0;\n\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            this.anchorItem.style.position = 'absolute';\n            this.anchorItem.style.height = '0px';\n            this.anchorItem.style.width = '20px';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            this.onResize();\n            this.loadItems();\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        onResize(e) {\n            // On resize need to recalculate the translateY values for the elements\n            \n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            if (this.requestInProgress) {\n                return;\n            }\n\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            /**\n             * if delta is greater than 0 then user is scrolling down\n             */\n            if (delta > 0) {\n                \n                // might not need this\n                if (this.requestInProgress) {\n                    return;\n                }\n\n                // const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n                const normalizedLastItemIndex = this.lastPhysicalItemIndex % PHYSICAL_ITEMS;\n                const lastItemTranslateY = ++this.physicalItems[normalizedLastItemIndex].dataset.translateY;\n                // const proximityToLastPhysicalItem = lastItemTranslateY - (this.scroller.scrollTop + this.scroller.offsetHeight);\n                const proximityToLastPhysicalItem = (this.lastPhysicalItemTranslateY - (this.lastPhysicalItem.offsetHeight + 10)) - (this.scroller.scrollTop + this.scroller.offsetHeight);\n\n                // if (!this.requestInProgress && (scrollBoundary > this.virtualItems[normalizedLastItemIndex].dataset.translateY)) {\n                if (!this.requestInProgress && (proximityToLastPhysicalItem < 300)) {\n                // if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    this.loadItems();\n                    // something where we say fill lower bottom\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n\n            } else if (delta < 0) {\n\n                if (this.requestInProgress) {\n                    return;\n                }\n                \n                // const firstItemIndex = Math.max(0, (this.firstAttachedItem - 10) % PHYSICAL_ITEMS);\n                // const firstItemIndex = Math.max(0, (this.firstAttachedItem - 10));\n                // const scrollProximity = this.scroller.scrollTop - this.virtualItems[firstItemIndex % PHYSICAL_ITEMS].dataset.translateY;\n\n                const normalizeFirstItemIndex = this.firstPhysicalItemIndex % PHYSICAL_ITEMS;\n                const firstItemTranslateY = ++this.physicalItems[normalizeFirstItemIndex].dataset.translateY;\n                // const proximityToFirstPhysicalItem = this.scroller.scrollTop - firstItemTranslateY;\n\n                const itemsSpace = this.lastPhysicalItemIndex - PHYSICAL_ITEMS + 1;\n                const approximateEmptySpace = itemsSpace * (this.loadingItemHeight + 10);\n                // console.log(approximateEmptySpace);\n                // console.log('Appriximate to fist item: ', this.scroller.scrollTop - approximateEmptySpace);\n                const proximityToFirstPhysicalItem = this.scroller.scrollTop - approximateEmptySpace;\n\n                // console.log('Anchor Height: ', this.anchorItem.offsetHeight);\n                // console.log('Scroller scrolltop: ', this.scroller.scrollTop);\n                // console.log('Distance: ', this.scroller.scrollTop - this.anchorItem.offsetHeight);\n\n                if (!this.requestInProgress && this.firstPhysicalItemIndex !== 0 && (proximityToFirstPhysicalItem < 300)) {\n                    // console.log('First Item: ', this.firstPhysicalItemIndex);\n                    // console.log('Last Item: ', this.lastPhysicalItemIndex);\n                    // console.log('First item: ', this.physicalItems[normalizeFirstItemIndex]);\n                    // console.log('Proximity to first Item: ', proximityToFirstPhysicalItem);\n\n                    // could possibly check here instead for this.firstPhysicalItemIndex === 0\n                    this.loadItemsUp();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n                }\n            }\n        }\n\n        loadItems() {\n            // if (this.count > 15) {\n            //     return;\n            // }\n\n            this.requestInProgress = true;\n\n            let loadingHeight = this.scrollRunwayEnd;\n\n            // instead of appending 10 times, just append once\n            // let addingElems = false;\n            // const frag = document.createDocumentFragment();\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                // Experimental - Transform instead of removing elements\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingHeight}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    // addingElems = true;\n                    // frag.appendChild(loadingItem);\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                loadingHeight += this.loadingItemHeight + 10; // loadingHeight is more of loadingTranslateYValue\n                // loadingHeight += this.loadingItemHeight + 10;\n            }\n\n            // instead of appending 10 times, just append once\n            // if (addingElems) {\n            //     this.scroller.appendChild(frag);\n            // }\n\n            // this.scrollRunway.style.transform = `translate(0,${this.loadingHeight}px)`;\n\n            const nextIndexToPopulate = this.lastPhysicalItemIndex + 1;\n            // Check the cache\n            if (this.itemsCacheData[nextIndexToPopulate]) {\n                // use cache to populate items\n                this.populateItems(this.itemsCacheData.slice(nextIndexToPopulate, nextIndexToPopulate + 10), true);\n            } else {\n                // 10 items\n                this.dataSource.next().then((response) => {\n                    this.populateItems(response, false);\n                });\n            }\n        }\n\n        populateItems(items, fromCache) {\n            // console.log('Loading: ', this.loadingItems);\n\n            const currentCacheDataLength = this.itemsCacheData.length;\n            const nextIndexToPopulate = this.lastPhysicalItemIndex + 1;\n\n            let itemTranslateY = 0;\n\n            // if (fromCache) {\n            //     const normalizeLastItemIndex = this.lastPhysicalItemIndex % PHYSICAL_ITEMS;\n            //     const lastPhysicalItem = this.physicalItems[normalizeLastItemIndex];\n            //     const lastPhysicalItemTranslateY = ++lastPhysicalItem.dataset.translateY;\n            //     const lastPhysicalItemHeight = lastPhysicalItem.offsetHeight;\n            //     itemTranslateY = lastPhysicalItemTranslateY + (lastPhysicalItemHeight + 10);\n            // } else {\n            //     itemTranslateY = this.scrollRunwayEnd;\n            // }\n\n\n\n            // const normalizeLastItemIndex = this.lastPhysicalItemIndex % PHYSICAL_ITEMS;\n            // const lastPhysicalItem = this.physicalItems[normalizeLastItemIndex];\n            // let lastPhysicalItemTranslateY = 0;\n            // let lastPhysicalItemHeight = 0;\n\n            // if (lastPhysicalItem) {\n            //     lastPhysicalItemTranslateY = ++this.physicalItems[normalizeLastItemIndex].dataset.translateY;\n            //     lastPhysicalItemHeight = this.physicalItems[normalizeLastItemIndex].offsetHeight;\n            //     itemTranslateY = lastPhysicalItemTranslateY + (lastPhysicalItemHeight + 10);\n            // }\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[i]) {\n                    this.loadingItems[i].classList.add('invisible');\n                }\n\n                const itemIndex = (nextIndexToPopulate + i) % PHYSICAL_ITEMS;\n\n                // const hasItem = this.virtualItems[itemIndex] && this.virtualItems.length === PHYSICAL_ITEMS;\n                const hasReusableItem = this.physicalItems[itemIndex] && this.physicalItems.length === PHYSICAL_ITEMS;\n\n                const item = hasReusableItem ? this.dataSource.render(items[i], this.physicalItems[itemIndex]) : this.dataSource.render(items[i]);\n\n                // Set the translateY value\n                item.style.position = 'absolute';\n                // item.style.transform = `translateY(${itemTranslateY}px)`;\n                item.style.transform = `translateY(${this.lastPhysicalItemTranslateY}px)`;\n                item.style.width = '92%';\n                // We need these values to animate elements when removed\n                // item.dataset.translateY = itemTranslateY;\n                item.dataset.translateY = this.lastPhysicalItemTranslateY;\n\n                if (!hasReusableItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                // We need to show right scrollbar size\n                if (!fromCache) {\n                    this.scrollRunwayEnd += item.offsetHeight + 10; // make 10 a constant\n                }\n                // itemTranslateY += item.offsetHeight + 10;\n                this.lastPhysicalItemTranslateY += item.offsetHeight + 10;\n                \n                this.physicalItems[itemIndex] = item;\n                // this.itemsCacheData.push(items[i]);\n                this.itemsCacheData[currentCacheDataLength + i] = items[i];\n            }\n            \n            // This uses the updated physicalItemIndex props\n            this.calculatePhysicalItemsIndex(items.length);\n\n            // Update runway translate to update scrollbar\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        loadItemsUp() {\n            // if (this.firstPhysicalItemIndex === 0) {\n            //     // we have reached the top\n            //     return;\n            // }\n\n            this.requestInProgress = true;\n\n            const normalizeFirstItemIndex = this.firstPhysicalItemIndex % PHYSICAL_ITEMS;\n            let loadingItemTranslateY = ++this.physicalItems[normalizeFirstItemIndex].dataset.translateY - (this.loadingItemHeight + 10);\n\n            // for (let i = 0; i < 10; i += 1) {\n            for (let i = 9; i >= 0; i -= 1) {\n\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingItemTranslateY}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    // addingElems = true;\n                    // frag.appendChild(loadingItem);\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                loadingItemTranslateY -= (this.loadingItemHeight + 10);\n            }\n\n            this.populateItemsTop();\n        }\n\n        populateItemsTop() {\n\n            const normalizeFirstItemIndex = this.firstPhysicalItemIndex % PHYSICAL_ITEMS;\n            const firstPhysicalItemTranslateY = ++this.physicalItems[normalizeFirstItemIndex].dataset.translateY;\n            const firstPhysicalItemHeight = this.physicalItems[normalizeFirstItemIndex].offsetHeight;\n            const itemBeforeFirstPhysicalItemIndex = this.firstPhysicalItemIndex - 1;\n            // const firstPhysicalItemIndex = this.firstPhysicalItemIndex;\n\n            let itemTranslateY = firstPhysicalItemTranslateY - (firstPhysicalItemHeight + 10);\n            // const firstItemIndex = Math.max(0, (this.firstAttachedItem - 10)) - 1;\n\n            // looping backwards to grab the right data from cache, maybe look into looping forwards\n            // for readability\n            for (let i = itemBeforeFirstPhysicalItemIndex; i > itemBeforeFirstPhysicalItemIndex - 10; i -= 1) {\n            // for (let i = (this.firstPhysicalItemIndex - 10); i < this.firstPhysicalItemIndex; i += 1) {\n\n                if (this.loadingItems[i % 10]) {\n                    this.loadingItems[i % 10].classList.add('invisible');\n                }\n\n                // revisit this logic\n                // const reusableItemIndex = (this.lastPhysicalItemIndex - (PHYSICAL_ITEMS - 1 - i)) % PHYSICAL_ITEMS;\n                // const reusableItemIndex = (this.firstPhysicalItemIndex - (10 - i)) % PHYSICAL_ITEMS;\n\n                const reusableItemIndex = i % PHYSICAL_ITEMS;\n                console.log('Reusbale last index: ', this.lastPhysicalItemIndex);\n                console.log('Reusable index: ', reusableItemIndex);\n\n                // const itemIndex = (this.lastAttachedItem - (10 - 1 - i)) % PHYSICAL_ITEMS;\n                const hasItem = this.physicalItems[reusableItemIndex] && this.physicalItems.length === PHYSICAL_ITEMS;\n                const item = hasItem ? this.dataSource.render(this.itemsCacheData[i], this.physicalItems[reusableItemIndex]) : this.dataSource.render(this.itemsCacheData[i]);\n\n                item.style.position = 'absolute';\n                // item.style.transform = `translateY(${itemTranslateY}px)`;\n                item.style.transform = `translateY(${this.firstPhysicalItemTranslateY}px)`\n                item.style.width = '92%';\n                // We need these values to animate elements when removed\n                // item.dataset.translateY = itemTranslateY;\n                item.dataset.translateY = this.firstPhysicalItemTranslateY;\n\n                // this should never go inside qhen scrolling up otherwise we messed up\n                if (!hasItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                // itemTranslateY -= (item.offsetHeight + 10);\n                this.firstPhysicalItemTranslateY -= (item.offsetHeight + 10);\n                console.log('TranslateY: ', this.firstPhysicalItemTranslateY);\n                \n                this.physicalItems[reusableItemIndex] = item;\n            }\n\n            // Hmm will this work?\n            this.calculatePhysicalItemsIndex(-10);\n\n            // this.firstAttachedItem = index;\n            // this.lastAttachedItem = this.firstAttachedItem + (10 - 1);\n\n            this.requestInProgress = false;\n        }\n\n        calculatePhysicalItemsIndex(itemsLength) {\n\n            this.lastPhysicalItemIndex += itemsLength;\n            this.firstPhysicalItemIndex = Math.max(0, this.lastPhysicalItemIndex - (PHYSICAL_ITEMS - 1));\n            this.middlePhysicalItemIndex = this.firstPhysicalItemIndex + ((this.lastPhysicalItemIndex - this.firstPhysicalItemIndex + 1) / 2);\n\n            const lastPhysicalItem = this.physicalItems[this.lastPhysicalItemIndex % PHYSICAL_ITEMS];\n            const firstPhysicalItem = this.physicalItems[this.firstPhysicalItemIndex % PHYSICAL_ITEMS];\n            this.firstPhysicalItem = this.physicalItems[this.firstPhysicalItemIndex % PHYSICAL_ITEMS];\n            this.lastPhysicalItem = this.physicalItems[this.lastPhysicalItemIndex % PHYSICAL_ITEMS];\n            this.lastPhysicalItemTranslateY = parseInt(lastPhysicalItem.dataset.translateY, 10) + (lastPhysicalItem.offsetHeight + 10);\n            this.firstPhysicalItemTranslateY = parseInt(firstPhysicalItem.dataset.translateY, 10) - (firstPhysicalItem.offsetHeight + 10);\n\n            // Debug info\n            // console.log('firstPhysicalItemIndex: ', this.firstPhysicalItemIndex);\n            // console.log('middlePhysicalItemIndex: ', this.middlePhysicalItemIndex);\n            // console.log('lastPhysicalItemIndex: ', this.lastPhysicalItemIndex);\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            // this.target.style.transform = `translateX(${this.translateX}px)`;\n            // Since we are manipulating elements through translates we need to keep translateY\n            this.target.style.transform = `translate(${this.translateX}px, ${this.target.dataset.translateY}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                // const targetIndex = this.items.indexOf(this.target);\n                const targetIndex = this.virtualItems.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                // if (this.items.length < 6) {\n                //     this.loadItems();\n                // }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                // item.style.transform = '';\n                // item.style.transform = `translateY(${parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10}px)`;\n                // item.dataset.translateY\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.virtualItems.length; i += 1) {\n                const item = this.virtualItems[i];\n\n                // Move the card down then slide it up.\n                // item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.style.transform = `translateY(${item.dataset.translateY}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.virtualItems.length; i += 1) {\n                    const item = this.virtualItems[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    // item.style.transform = '';\n                    console.log('targetBCRheight: ', this.targetBCR.height);\n                    item.style.transform = `translateY(${parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10}px)`;\n                    item.dataset.translateY = parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10;\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            // this.target.style.transform = 'none';\n            this.target.style.transform = `translateY(${this.target.dataset.translateY}px)`;\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('components/infinite-scroller-v2',[\n], function() {\n    'use strict';\n    \n    const RUNWAY_ITEMS = 50;\n    const RUNWAY_ITEMS_OPPOSITE = 10;\n    const SCROLL_RUNWAY = 2000;\n    const ANIMATION_DURATION_MS = 200;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            this.anchorScrollTop = 0;\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.firstAttachedItem = 0;\n            this.lastAttachedItem = 0;\n            this.virtualItems = [];\n            this.physicalItems = [];\n\n            this.virtualItemsCount = 0;\n            this.physicalItemsCount = 0;\n\n            this.items = [];\n            this.loadedItems = 0;\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            // this.anchorItem.style.position = 'absolute';\n            this.anchorItem.style.height = '1px';\n            this.anchorItem.style.width = '1px';\n            // this.anchorItem.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            // this.onResize();\n            // this.loadItems();\n            this.loadItemsExp(false);\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        loadItems() {\n            this.requestInProgress = true;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const loadingItem = this.dataSource.createLoadingElement();\n                this.loadingItems[i] = loadingItem;\n                this.scroller.appendChild(loadingItem);\n            }\n\n            // 20 items\n            // this.dataSource.next().then((response) => {\n            //     this.populateItems(response);\n            //     return this.dataSource.next();\n            // }).then((response) => {\n            //     this.populateItems(response);\n            // });\n\n            // 10 items\n            this.dataSource.next().then((response) => {\n                this.populateItems(response);\n                return this.dataSource.next();\n            });\n        }\n\n        loadItemsExp(firstLoad) {\n            if (this.count > 15) {\n                return;\n            }\n\n            this.requestInProgress = true;\n            let loadingHeight = this.scrollRunwayEnd;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                // Experimental - Transform instead of removing elements\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingHeight}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                // Experimental - Transform instead of removing elements\n                loadingHeight += loadingItem.offsetHeight + 10;\n            }\n\n            // console.log('LOADING RUNWAY END: ', this.scrollRunwayEnd);\n            // this.scrollRunway.style.transform = `translate(0,${this.loadingHeight}px)`;\n\n            if (firstLoad) {\n                console.log('first load');\n                let firstLoadItems = [];\n                this.dataSource.next().then((response) => {\n                    firstLoadItems = firstLoadItems.concat(response);\n                    return this.dataSource.next();\n                }).then((response) => {\n                    firstLoadItems = firstLoadItems.concat(response);\n                    this.populateItemsExp(firstLoadItems);\n                });\n            } else {\n                // 10 items\n                this.dataSource.next().then((response) => {\n                    this.populateItemsExp(response);\n                    // return this.dataSource.next();\n                });\n            }\n        }\n\n        populateItems(items) {\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[0]) {\n                    this.scroller.removeChild(this.loadingItems[0]);\n                    this.loadingItems.splice(0, 1);\n                }\n                const item = this.dataSource.render(items[i]);\n                this.scroller.appendChild(item);\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                this.items.push(item);\n            }\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n        }\n\n        populateItemsExp(items) {\n            console.log('Hello');\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[i]) {\n                    this.loadingItems[i].classList.add('invisible');\n                }\n\n                const itemIndex = (this.firstAttachedItem + i) % 20;\n                const hasItem = this.virtualItems[itemIndex] && this.virtualItems.length === 20;\n\n                const item = hasItem ? this.dataSource.render(items[i], this.virtualItems[itemIndex]) : this.dataSource.render(items[i]);\n\n                // Experimental - Transform instead of removing elements\n                item.style.position = 'absolute';\n                item.style.transform = `translateY(${this.scrollRunwayEnd}px)`;\n                item.style.width = '92%';\n\n                if (!hasItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                \n                this.virtualItems[itemIndex] = item;\n                this.items.push(item);\n            }\n\n            this.lastAttachedItem = this.firstAttachedItem + (items.length - 1);\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        onResize(e) {\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // Reset cahced size of items in the scroller\n            for (let i = 0; i < this.items.length; i += 1) {\n                this.items[i].height = this.items[i].width = 0;\n            }\n\n            this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            if (delta > 0) {\n                // scrolling down\n                const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n\n                if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    // this.loadItems();\n\n                    this.firstAttachedItem = this.lastAttachedItem + 1;\n\n                    this.loadItemsExp();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n            } else {\n                // scrolling up\n                // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n            }\n        }\n\n        /**\n         * Sets the range of items which should be attached and attaches those items\n         */\n        fill(start, end) {\n            this.firstAttachedItem = Math.max(0, start);\n            this.lastAttachedItem = end;\n            this.attachContent();\n        }\n\n        getLoadingItem() {\n            const loadingItem = this.loadingItems.pop();\n            if (loadingItem) {\n                return loadingItem;\n            }\n\n            return this.dataSource.createLoadingElement();\n        }\n\n        attachContent(start, end) {\n            // here some logic to go fetch items i.e. scrolling down and not more virtualItems\n            // and just loading from virtual items\n\n        }\n\n        addItem() {\n            this.items.push({\n                data: null,\n                node: null\n            });\n        }\n\n        addContent(items) {\n            this.requestInProgress = false;\n            for (let i = 0; i < items.length; i += 1) {\n                this.addItem();\n                this.items[this.loadedItems++].data = items[i];\n            }\n            this.attachContent();\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            this.target.style.transform = `translateX(${this.translateX}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.items.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                if (this.items.length < 6) {\n                    this.loadItems();\n                }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                item.style.transform = '';\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.items.length; i += 1) {\n                const item = this.items[i];\n\n                // Move the card down then slide it up.\n                item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.items.length; i += 1) {\n                    const item = this.items[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    item.style.transform = '';\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            this.target.style.transform = 'none';\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('components/infinite-scroller',[\n], function() {\n    'use strict';\n    \n    const RUNWAY_ITEMS = 50;\n    const RUNWAY_ITEMS_OPPOSITE = 10;\n    const SCROLL_RUNWAY = 2000;\n    const ANIMATION_DURATION_MS = 200;\n    const PHYSICAL_ITEMS = 20;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            this.anchorScrollTop = 0;\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.firstAttachedItem = 0;\n            this.lastAttachedItem = 0;\n            this.virtualItems = [];\n            this.physicalItems = [];\n\n            this.virtualItemsCount = 0;\n            this.physicalItemsCount = 0;\n\n            this.items = [];\n            this.itemsData = [];\n            this.loadedItems = 0;\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            this.anchorItem.style.height = '0px';\n            this.anchorItem.style.width = '1px';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            // this.onResize();\n            // this.loadItems();\n            this.loadItems();\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        loadItems() {\n            if (this.count > 15) {\n                return;\n            }\n\n            this.requestInProgress = true;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const loadingItem = this.dataSource.createLoadingElement();\n                this.loadingItems[i] = loadingItem;\n                this.scroller.appendChild(loadingItem);\n            }\n\n            // 10 items\n            this.dataSource.next().then((response) => {\n                this.populateItems(response);\n            });\n        }\n\n        populateItems(items) {\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[0]) {\n                    this.scroller.removeChild(this.loadingItems[0]);\n                    this.loadingItems.splice(0, 1);\n                }\n                const item = this.dataSource.render(items[i]);\n                this.scroller.appendChild(item);\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                this.items.push(item);\n            }\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        onResize(e) {\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // Reset cahced size of items in the scroller\n            for (let i = 0; i < this.items.length; i += 1) {\n                this.items[i].height = this.items[i].width = 0;\n            }\n\n            this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            if (delta > 0) {\n                // scrolling down\n                const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n\n                if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    // this.loadItems();\n\n                    this.firstAttachedItem = this.lastAttachedItem + 1;\n\n                    this.loadItems();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n            } else {\n                // scrolling up\n                // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n            }\n        }\n\n        /**\n         * Sets the range of items which should be attached and attaches those items\n         */\n        fill(start, end) {\n            this.firstAttachedItem = Math.max(0, start);\n            this.lastAttachedItem = end;\n            this.attachContent();\n        }\n\n        getLoadingItem() {\n            const loadingItem = this.loadingItems.pop();\n            if (loadingItem) {\n                return loadingItem;\n            }\n\n            return this.dataSource.createLoadingElement();\n        }\n\n        attachContent(start, end) {\n            // here some logic to go fetch items i.e. scrolling down and not more virtualItems\n            // and just loading from virtual items\n\n        }\n\n        addItem() {\n            this.items.push({\n                data: null,\n                node: null\n            });\n        }\n\n        addContent(items) {\n            this.requestInProgress = false;\n            for (let i = 0; i < items.length; i += 1) {\n                this.addItem();\n                this.items[this.loadedItems++].data = items[i];\n            }\n            this.attachContent();\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            this.target.style.transform = `translateX(${this.translateX}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                // Update runway (i.e. update scrollbar)\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.items.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                if (this.items.length < 6) {\n                    this.loadItems();\n                }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                item.style.transform = '';\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.items.length; i += 1) {\n                const item = this.items[i];\n\n                // Move the card down then slide it up.\n                item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.items.length; i += 1) {\n                    const item = this.items[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    item.style.transform = '';\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            this.target.style.transform = 'none';\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('datasource/messages',[\n], function() {\n    'use strict';\n    \n    class Messages {\n        constructor(options) {\n            this.loadingTemplate = document.querySelector('#templates .scroller__item--loading');\n            this.messageTemplate = document.querySelector('#templates .scroller__item');\n            \n            this.url = options.url;\n            this.dataEndpoint = options.dataEndpoint;\n            this.dataUrl = `${this.url}${this.dataEndpoint}`;\n\n            this.nextItem = 0;\n\n            this.nextPageToken = null;\n        }\n\n        /**\n         * Fetch items from datasource.\n         */\n        fetch(obj, limit) {\n            return new Promise((resolve, reject) => {\n\n                let params = obj.params;\n                if (params && typeof params === 'object') {\n                    params = Object.keys(params).map((key) => {\n                        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                    }).join('&');\n                }\n\n                const url = params ? obj.url + '?' + params : obj.url;\n\n                let xhr = new XMLHttpRequest();\n                xhr.open(obj.method || 'GET', url);\n\n                xhr.onload = () => {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        resolve(xhr.response);\n                    } else {\n                        reject(xhr.statusText);\n                    }\n                };\n\n                xhr.onerror = () => {\n                    reject(xhr.statusText);\n                };\n\n                // let params = obj.params;\n                // if (params && typeof params === 'object') {\n                //     params = Object.keys(params).map((key) => {\n                //         return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                //     }).join('&');\n                // }\n                xhr.send();\n            });\n        }\n\n        next() {\n            let options = {\n                method: 'GET',\n                url: this.dataUrl\n            };\n\n            if (this.nextPageToken) {\n                options.params = {\n                    pageToken: this.nextPageToken\n                };\n                // Object.assign(options, {\n                //     params: {\n                //         pageToken: this.nextPageToken\n                //     }\n                // });\n            }\n\n            return this.fetch(options).then((response) => {\n                let jsonResponse = JSON.parse(response);\n                this.nextPageToken = jsonResponse.pageToken;\n                return jsonResponse.messages;\n            });\n\n            // return this.fetch(options);\n        }\n\n        /**\n         * Create a loading element, all loading elements are identical\n         */\n        createLoadingElement() {\n            return this.loadingTemplate.cloneNode(true);\n        }\n\n        /**\n         * Render an item, reusing the provided div if provided\n         */\n        render(item, div) {\n            div = div || this.messageTemplate.cloneNode(true);\n\n            div.dataset.id = item.id;\n\n            div.querySelector('.card__avatar').src = `${this.url}${item.author.photoUrl}`;\n            div.querySelector('.card__title').textContent = item.author.name;\n            div.querySelector('.card__subtitle').textContent = this.timeSince(new Date(item.updated)); //item.updated.toString();\n            div.querySelector('.card__content').textContent = item.content;\n\n            return div;\n        }\n\n        timeSince(date) {\n            if (typeof date !== 'object') {\n                date = new Date(date);\n            }\n\n            let seconds = Math.floor((new Date() - date) / 1000),\n                interval = Math.floor(seconds / 31536000);\n\n            if (interval >= 1) {\n                return `${interval} year${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 2592000);\n            if (interval >= 1) {\n                return `${interval} month${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 86400);\n            if (interval >= 1) {\n                return `${interval} day${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 3600);\n            if (interval >= 1) {\n                return `${interval} hour${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 3600);\n            if (interval >= 1) {\n                return `${interval} minute${interval > 1 ? 's' : ''} ago`;\n            }\n\n            return `${interval} second${interval > 1 ? 's' : ''} ago`;\n        }\n    }\n\n    return Messages;\n});"]}