{"version":3,"sources":["app.js","main.js","components/infinite-scroller-experimental.js","components/infinite-scroller-v2.js","components/infinite-scroller.js","datasource/messages.js"],"names":["requirejs","config","baseUrl","paths","app","main","init","define","InfiniteScroller","InfiniteScrollerExperimental","Messages","scroller","document","querySelector","scrollerExp","messagesSource","url","dataEndpoint","this","infiniteScroller","swipeable","infiniteScrollerExp","dataSource","options","_classCallCheck","PHYSICAL_ITEMS","physicalItems","PAGE_SIZE","pageSize","PROXIMITY_BOUNDARY","proximityBoundary","itemsCacheData","loadingItemHeight","loadingItemWidth","loadingItems","firstPhysicalItemIndex","middlePhysicalItemIndex","lastPhysicalItemIndex","firstPhysicalItem","lastPhysicalItem","firstPhysicalItemTranslateY","lastPhysicalItemTranslateY","requestInProgress","target","targetBCR","targetX","startX","currentX","translateX","draggingItem","scrollRunway","createElement","scrollRunwayEndBefore","scrollRunwayEnd","style","position","height","width","transition","appendChild","previousScrollTop","itemsRemovedInSuccession","addEventListeners","onResize","loadItems","_createClass","key","value","_this","window","addEventListener","e","onScroll","onTouchStart","onTouchMove","onTouchEnd","loadingItem","createLoadingElement","offsetHeight","offsetWidth","removeChild","delta","scrollTop","actualLastPhysicalItemTranslateY","proximityToLastPhysicalItem","proximityToFirstPhysicalItem","loadItemsUp","_this2","loadingHeight","i","hasLoadingItem","transform","classList","remove","nextIndexToPopulate","populateItems","slice","next","then","response","items","fromCache","currentCacheDataLength","length","itemTranslateY","add","itemIndex","hasReusableItem","item","render","dataset","translateY","calculatePhysicalItemsIndex","loadingItemTranslateY","populateItemsTop","itemBeforeFirstPhysicalItemIndex","reusableItemIndex","hasItem","itemsLength","Math","max","parseInt","_this3","contains","getBoundingClientRect","touches","pageX","willChange","requestAnimationFrame","update","threshold","abs","_this4","normalizedDragDistance","opacity","pow","isNearlyAtStart","parentNode","targetTranslateY","targetIndex","indexOf","targetDataIndex","id","splice","animateOtherItemsIntoPosition","resetTarget","startIndex","_this5","onAnimationComplete","removeEventListener","_","anchorScrollTop","firstAttachedItem","lastAttachedItem","virtualItems","virtualItemsCount","physicalItemsCount","loadedItems","anchorItem","anchorItemHeight","count","loadItemsExp","firstLoad","console","log","firstLoadItems","concat","populateItemsExp","push","scrollBoundary","scrollHeight","start","end","attachContent","pop","data","node","addItem","_this6","itemsData","loadingTemplate","messageTemplate","dataUrl","nextItem","nextPageToken","obj","Promise","resolve","reject","params","_typeof","Object","keys","map","encodeURIComponent","join","xhr","XMLHttpRequest","open","method","onload","status","statusText","onerror","send","pageToken","fetch","jsonResponse","JSON","parse","messages","cloneNode","div","src","author","photoUrl","textContent","name","timeSince","Date","updated","content","date","seconds","floor","interval"],"mappings":"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","file":"main.min.js","sourcesContent":["// For any third party dependencies, like jQuery, place them in the lib folder.\n\n// Configure loading modules from the lib directory,\n// except for 'app' ones, which are in a sibling\n// directory.\nrequirejs.config({\n    baseUrl: 'src/javascript',\n    paths: {\n        app: '../dist'\n    }\n});\n\n// Start loading the main app file. Put all of\n// your application logic in there.\nrequirejs(['main'], function(main) {\n    main.init();\n});","define('main', [\n    'components/infinite-scroller',\n    'components/infinite-scroller-experimental',\n    'datasource/messages'\n], function(\n    InfiniteScroller,\n    InfiniteScrollerExperimental,\n    Messages\n) {\n    'use strict';\n    \n    return {\n        init: function() {\n            const scroller = document.querySelector('#messages');\n            const scrollerExp = document.querySelector('#messages-exp');\n            const messagesSource = new Messages({\n                url: 'https://message-list.appspot.com',\n                dataEndpoint: '/messages'\n            });\n\n            if (scroller) {\n                this.infiniteScroller = new InfiniteScroller(scroller, messagesSource, {\n                    swipeable: true\n                });\n            }\n\n            if (scrollerExp) {\n                this.infiniteScrollerExp = new InfiniteScrollerExperimental(scrollerExp, messagesSource, {\n                    swipeable: true\n                });\n            }\n        }\n    };\n});","define('components/infinite-scroller-experimental',[\n], function() {\n    'use strict';\n    \n    const PHYSICAL_ITEMS = 20;\n    const PAGE_SIZE = 10;\n    const PROXIMITY_BOUNDARY = 300;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            // Options\n            this.swipeable = options.swipeable;\n            this.PHYSICAL_ITEMS = options.physicalItems || PHYSICAL_ITEMS;\n            this.PAGE_SIZE = options.pageSize || PAGE_SIZE;\n            this.PROXIMITY_BOUNDARY = options.proximityBoundary || PROXIMITY_BOUNDARY;\n            \n            // This will hold a cache of the data sent from server\n            this.itemsCacheData = [];\n\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.physicalItems = [];\n            this.firstPhysicalItemIndex = -1;\n            this.middlePhysicalItemIndex = -1;\n            this.lastPhysicalItemIndex = -1;\n            this.firstPhysicalItem = null;\n            this.lastPhysicalItem = null;\n            this.firstPhysicalItemTranslateY = 0;\n            this.lastPhysicalItemTranslateY = 0;\n\n            this.requestInProgress = false;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.itemsRemovedInSuccession = 0;\n\n            this.addEventListeners();\n\n            this.onResize();\n            this.loadItems();\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        onResize(e) {\n            // On resize need to recalculate the translateY values for the elements\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            if (this.requestInProgress) {\n                return;\n            }\n\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            /**\n             * if delta is greater than 0 then user is scrolling down\n             */\n            if (delta > 0) {\n                const actualLastPhysicalItemTranslateY = this.lastPhysicalItemTranslateY - (this.lastPhysicalItem.offsetHeight + 10);\n                const proximityToLastPhysicalItem = actualLastPhysicalItemTranslateY - (this.scroller.scrollTop + this.scroller.offsetHeight);\n\n                if (!this.requestInProgress && (proximityToLastPhysicalItem < this.PROXIMITY_BOUNDARY)) {\n                    this.loadItems();\n                }\n\n            } else if (delta < 0) {\n                const proximityToFirstPhysicalItem = this.scroller.scrollTop - this.firstPhysicalItemTranslateY;\n\n                if (!this.requestInProgress && this.firstPhysicalItemIndex !== 0 && (proximityToFirstPhysicalItem < this.PROXIMITY_BOUNDARY)) {\n                    this.loadItemsUp();\n                }\n            }\n        }\n\n        loadItems() {\n            this.requestInProgress = true;\n\n            let loadingHeight = this.lastPhysicalItemTranslateY;\n\n            // instead of appending 10 times, just append once\n            // let addingElems = false;\n            // const frag = document.createDocumentFragment();\n\n            // Loading items\n            for (let i = 0; i < this.PAGE_SIZE; i += 1) {\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingHeight}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    // addingElems = true;\n                    // frag.appendChild(loadingItem);\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                this.loadingItems[i] = loadingItem;\n\n                loadingHeight += this.loadingItemHeight + 10; // loadingHeight is more of loadingTranslateYValue\n            }\n\n            // instead of appending 10 times, just append once\n            // if (addingElems) {\n            //     this.scroller.appendChild(frag);\n            // }\n\n            const nextIndexToPopulate = this.lastPhysicalItemIndex + 1;\n            // Check the cache\n            if (this.itemsCacheData[nextIndexToPopulate]) {\n                // use cache to populate items\n                this.populateItems(this.itemsCacheData.slice(nextIndexToPopulate, nextIndexToPopulate + 10), true);\n            } else {\n                // 10 items\n                this.dataSource.next().then((response) => {\n                    this.populateItems(response, false);\n                });\n            }\n        }\n\n        populateItems(items, fromCache) {\n            const currentCacheDataLength = this.itemsCacheData.length;\n            const nextIndexToPopulate = this.lastPhysicalItemIndex + 1;\n\n            // let itemTranslateY = 0;\n            let itemTranslateY = this.lastPhysicalItemTranslateY;\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[i]) {\n                    this.loadingItems[i].classList.add('invisible');\n                }\n\n                const itemIndex = (nextIndexToPopulate + i) % this.PHYSICAL_ITEMS;\n                const hasReusableItem = this.physicalItems[itemIndex];\n                const item = hasReusableItem ? this.dataSource.render(items[i], this.physicalItems[itemIndex]) : this.dataSource.render(items[i]);\n\n                item.style.position = 'absolute';\n                item.style.transform = `translateY(${itemTranslateY}px)`;\n                item.dataset.translateY = itemTranslateY;\n                item.style.width = '92%';\n\n                if (!hasReusableItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                // We need to show right scrollbar size\n                if (!fromCache) {\n                    this.scrollRunwayEnd += item.offsetHeight + 10; // make 10 a constant\n                }\n                itemTranslateY += item.offsetHeight + 10;\n                \n                this.physicalItems[itemIndex] = item;\n                // this.itemsCacheData.push(items[i]);\n                this.itemsCacheData[currentCacheDataLength + i] = items[i];\n            }\n            \n            // This uses the updated physicalItemIndex props\n            this.calculatePhysicalItemsIndex(items.length);\n\n            // Update runway translate to update scrollbar\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n        }\n\n        loadItemsUp() {\n            this.requestInProgress = true;\n\n            let loadingItemTranslateY = this.firstPhysicalItemTranslateY;\n\n            for (let i = 9; i >= 0; i -= 1) {\n\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingItemTranslateY}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    // addingElems = true;\n                    // frag.appendChild(loadingItem);\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                this.loadingItems[i] = loadingItem;\n\n                loadingItemTranslateY -= (this.loadingItemHeight + 10);\n            }\n\n            this.populateItemsTop();\n        }\n\n        populateItemsTop() {\n\n            const itemBeforeFirstPhysicalItemIndex = this.firstPhysicalItemIndex - 1;\n\n            let itemTranslateY = this.firstPhysicalItemTranslateY;\n\n            for (let i = itemBeforeFirstPhysicalItemIndex; i > itemBeforeFirstPhysicalItemIndex - 10; i -= 1) {\n\n                if (this.loadingItems[i % 10]) {\n                    this.loadingItems[i % 10].classList.add('invisible');\n                }\n\n                const reusableItemIndex = i % this.PHYSICAL_ITEMS;\n                const hasItem = this.physicalItems[reusableItemIndex];\n                const item = hasItem ? this.dataSource.render(this.itemsCacheData[i], this.physicalItems[reusableItemIndex]) : this.dataSource.render(this.itemsCacheData[i]);\n\n                item.style.position = 'absolute';\n                item.style.transform = `translateY(${itemTranslateY}px)`;\n                // We need these values to animate elements when removed\n                item.dataset.translateY = itemTranslateY;\n                item.style.width = '92%';\n\n                // this should never go inside when scrolling up otherwise we messed up\n                if (!hasItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                itemTranslateY -= (item.offsetHeight + 10);\n                \n                this.physicalItems[reusableItemIndex] = item;\n            }\n\n            this.calculatePhysicalItemsIndex(-10);\n            this.requestInProgress = false;\n        }\n\n        calculatePhysicalItemsIndex(itemsLength) {\n            this.lastPhysicalItemIndex += itemsLength;\n            this.firstPhysicalItemIndex = Math.max(0, this.lastPhysicalItemIndex - (this.PHYSICAL_ITEMS - 1));\n            this.middlePhysicalItemIndex = this.firstPhysicalItemIndex + ((this.lastPhysicalItemIndex - this.firstPhysicalItemIndex + 1) / 2);\n\n            this.firstPhysicalItem = this.physicalItems[this.firstPhysicalItemIndex % this.PHYSICAL_ITEMS] || this.physicalItems[(this.firstPhysicalItemIndex + this.itemsRemovedInSuccession) % this.PHYSICAL_ITEMS];\n            this.lastPhysicalItem = this.physicalItems[this.lastPhysicalItemIndex % this.PHYSICAL_ITEMS] || this.physicalItems[(this.lastPhysicalItemIndex - this.itemsRemovedInSuccession) % this.PHYSICAL_ITEMS];;\n\n            // this is used for the next\n            this.firstPhysicalItemTranslateY = parseInt(this.firstPhysicalItem.dataset.translateY, 10) - (this.firstPhysicalItem.offsetHeight + 10);\n            this.lastPhysicalItemTranslateY = parseInt(this.lastPhysicalItem.dataset.translateY, 10) + (this.lastPhysicalItem.offsetHeight + 10);\n            \n            this.itemsRemovedInSuccession = 0;\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            // Since we are manipulating elements through translates we need to keep translateY\n            this.target.style.transform = `translate(${this.translateX}px, ${this.target.dataset.translateY}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                const targetTranslateY = this.target.dataset.translateY;\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.physicalItems.indexOf(this.target);\n                const targetDataIndex = parseInt(this.target.dataset.id, 10);\n                this.physicalItems.splice(targetIndex, 1);\n                this.itemsCacheData.splice(targetDataIndex - 1, 1);\n\n                this.itemsRemovedInSuccession += 1;\n\n                this.animateOtherItemsIntoPosition(targetIndex, targetTranslateY);\n\n                // if (this.physicalItems.length < 6) {\n                //     this.loadItems();\n                // }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex, translateY) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.physicalItems.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                // item.style.transform = '';\n                // item.style.transform = `translateY(${parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10}px)`;\n                // item.dataset.translateY\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = 0; i < this.physicalItems.length; i += 1) {\n                const item = this.physicalItems[i];\n\n                if (item.dataset.translateY > translateY) {\n                    // Move the card down then slide it up.\n                    // item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                    item.style.transform = `translateY(${item.dataset.translateY}px)`;\n                    item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n                }\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = 0; i < this.physicalItems.length; i += 1) {\n                    const item = this.physicalItems[i];\n\n                    if (item.dataset.translateY > translateY) {\n                        item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                        item.style.transform = `translateY(${parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10}px)`;\n                        item.dataset.translateY = parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10;\n                    }\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            // this.target.style.transform = 'none';\n            this.target.style.transform = `translateY(${this.target.dataset.translateY}px)`;\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('components/infinite-scroller-v2',[\n], function() {\n    'use strict';\n    \n    const RUNWAY_ITEMS = 50;\n    const RUNWAY_ITEMS_OPPOSITE = 10;\n    const SCROLL_RUNWAY = 2000;\n    const ANIMATION_DURATION_MS = 200;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            this.anchorScrollTop = 0;\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.firstAttachedItem = 0;\n            this.lastAttachedItem = 0;\n            this.virtualItems = [];\n            this.physicalItems = [];\n\n            this.virtualItemsCount = 0;\n            this.physicalItemsCount = 0;\n\n            this.items = [];\n            this.loadedItems = 0;\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            // this.anchorItem.style.position = 'absolute';\n            this.anchorItem.style.height = '1px';\n            this.anchorItem.style.width = '1px';\n            // this.anchorItem.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            // this.onResize();\n            // this.loadItems();\n            this.loadItemsExp(false);\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        loadItems() {\n            this.requestInProgress = true;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const loadingItem = this.dataSource.createLoadingElement();\n                this.loadingItems[i] = loadingItem;\n                this.scroller.appendChild(loadingItem);\n            }\n\n            // 20 items\n            // this.dataSource.next().then((response) => {\n            //     this.populateItems(response);\n            //     return this.dataSource.next();\n            // }).then((response) => {\n            //     this.populateItems(response);\n            // });\n\n            // 10 items\n            this.dataSource.next().then((response) => {\n                this.populateItems(response);\n                return this.dataSource.next();\n            });\n        }\n\n        loadItemsExp(firstLoad) {\n            if (this.count > 15) {\n                return;\n            }\n\n            this.requestInProgress = true;\n            let loadingHeight = this.scrollRunwayEnd;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                // Experimental - Transform instead of removing elements\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingHeight}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                // Experimental - Transform instead of removing elements\n                loadingHeight += loadingItem.offsetHeight + 10;\n            }\n\n            // console.log('LOADING RUNWAY END: ', this.scrollRunwayEnd);\n            // this.scrollRunway.style.transform = `translate(0,${this.loadingHeight}px)`;\n\n            if (firstLoad) {\n                console.log('first load');\n                let firstLoadItems = [];\n                this.dataSource.next().then((response) => {\n                    firstLoadItems = firstLoadItems.concat(response);\n                    return this.dataSource.next();\n                }).then((response) => {\n                    firstLoadItems = firstLoadItems.concat(response);\n                    this.populateItemsExp(firstLoadItems);\n                });\n            } else {\n                // 10 items\n                this.dataSource.next().then((response) => {\n                    this.populateItemsExp(response);\n                    // return this.dataSource.next();\n                });\n            }\n        }\n\n        populateItems(items) {\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[0]) {\n                    this.scroller.removeChild(this.loadingItems[0]);\n                    this.loadingItems.splice(0, 1);\n                }\n                const item = this.dataSource.render(items[i]);\n                this.scroller.appendChild(item);\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                this.items.push(item);\n            }\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n        }\n\n        populateItemsExp(items) {\n            console.log('Hello');\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[i]) {\n                    this.loadingItems[i].classList.add('invisible');\n                }\n\n                const itemIndex = (this.firstAttachedItem + i) % 20;\n                const hasItem = this.virtualItems[itemIndex] && this.virtualItems.length === 20;\n\n                const item = hasItem ? this.dataSource.render(items[i], this.virtualItems[itemIndex]) : this.dataSource.render(items[i]);\n\n                // Experimental - Transform instead of removing elements\n                item.style.position = 'absolute';\n                item.style.transform = `translateY(${this.scrollRunwayEnd}px)`;\n                item.style.width = '92%';\n\n                if (!hasItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                \n                this.virtualItems[itemIndex] = item;\n                this.items.push(item);\n            }\n\n            this.lastAttachedItem = this.firstAttachedItem + (items.length - 1);\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        onResize(e) {\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // Reset cahced size of items in the scroller\n            for (let i = 0; i < this.items.length; i += 1) {\n                this.items[i].height = this.items[i].width = 0;\n            }\n\n            this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            if (delta > 0) {\n                // scrolling down\n                const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n\n                if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    // this.loadItems();\n\n                    this.firstAttachedItem = this.lastAttachedItem + 1;\n\n                    this.loadItemsExp();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n            } else {\n                // scrolling up\n                // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n            }\n        }\n\n        /**\n         * Sets the range of items which should be attached and attaches those items\n         */\n        fill(start, end) {\n            this.firstAttachedItem = Math.max(0, start);\n            this.lastAttachedItem = end;\n            this.attachContent();\n        }\n\n        getLoadingItem() {\n            const loadingItem = this.loadingItems.pop();\n            if (loadingItem) {\n                return loadingItem;\n            }\n\n            return this.dataSource.createLoadingElement();\n        }\n\n        attachContent(start, end) {\n            // here some logic to go fetch items i.e. scrolling down and not more virtualItems\n            // and just loading from virtual items\n\n        }\n\n        addItem() {\n            this.items.push({\n                data: null,\n                node: null\n            });\n        }\n\n        addContent(items) {\n            this.requestInProgress = false;\n            for (let i = 0; i < items.length; i += 1) {\n                this.addItem();\n                this.items[this.loadedItems++].data = items[i];\n            }\n            this.attachContent();\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            this.target.style.transform = `translateX(${this.translateX}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.items.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                if (this.items.length < 6) {\n                    this.loadItems();\n                }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                item.style.transform = '';\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.items.length; i += 1) {\n                const item = this.items[i];\n\n                // Move the card down then slide it up.\n                item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.items.length; i += 1) {\n                    const item = this.items[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    item.style.transform = '';\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            this.target.style.transform = 'none';\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('components/infinite-scroller',[\n], function() {\n    'use strict';\n    \n    const RUNWAY_ITEMS = 50;\n    const RUNWAY_ITEMS_OPPOSITE = 10;\n    const SCROLL_RUNWAY = 2000;\n    const ANIMATION_DURATION_MS = 200;\n    const PHYSICAL_ITEMS = 20;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            this.anchorScrollTop = 0;\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.firstAttachedItem = 0;\n            this.lastAttachedItem = 0;\n            this.virtualItems = [];\n            this.physicalItems = [];\n\n            this.virtualItemsCount = 0;\n            this.physicalItemsCount = 0;\n\n            this.items = [];\n            this.itemsData = [];\n            this.loadedItems = 0;\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            this.anchorItem.style.height = '0px';\n            this.anchorItem.style.width = '1px';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            // this.onResize();\n            // this.loadItems();\n            this.loadItems();\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        loadItems() {\n            if (this.count > 15) {\n                return;\n            }\n\n            this.requestInProgress = true;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const loadingItem = this.dataSource.createLoadingElement();\n                this.loadingItems[i] = loadingItem;\n                this.scroller.appendChild(loadingItem);\n            }\n\n            // 10 items\n            this.dataSource.next().then((response) => {\n                this.populateItems(response);\n            });\n        }\n\n        populateItems(items) {\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[0]) {\n                    this.scroller.removeChild(this.loadingItems[0]);\n                    this.loadingItems.splice(0, 1);\n                }\n                const item = this.dataSource.render(items[i]);\n                this.scroller.appendChild(item);\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                this.items.push(item);\n            }\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        onResize(e) {\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // Reset cahced size of items in the scroller\n            for (let i = 0; i < this.items.length; i += 1) {\n                this.items[i].height = this.items[i].width = 0;\n            }\n\n            this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            if (delta > 0) {\n                // scrolling down\n                const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n\n                if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    // this.loadItems();\n\n                    this.firstAttachedItem = this.lastAttachedItem + 1;\n\n                    this.loadItems();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n            } else {\n                // scrolling up\n                // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n            }\n        }\n\n        /**\n         * Sets the range of items which should be attached and attaches those items\n         */\n        fill(start, end) {\n            this.firstAttachedItem = Math.max(0, start);\n            this.lastAttachedItem = end;\n            this.attachContent();\n        }\n\n        getLoadingItem() {\n            const loadingItem = this.loadingItems.pop();\n            if (loadingItem) {\n                return loadingItem;\n            }\n\n            return this.dataSource.createLoadingElement();\n        }\n\n        attachContent(start, end) {\n            // here some logic to go fetch items i.e. scrolling down and not more virtualItems\n            // and just loading from virtual items\n\n        }\n\n        addItem() {\n            this.items.push({\n                data: null,\n                node: null\n            });\n        }\n\n        addContent(items) {\n            this.requestInProgress = false;\n            for (let i = 0; i < items.length; i += 1) {\n                this.addItem();\n                this.items[this.loadedItems++].data = items[i];\n            }\n            this.attachContent();\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            this.target.style.transform = `translateX(${this.translateX}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                // Update runway (i.e. update scrollbar)\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.items.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                if (this.items.length < 6) {\n                    this.loadItems();\n                }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                item.style.transform = '';\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.items.length; i += 1) {\n                const item = this.items[i];\n\n                // Move the card down then slide it up.\n                item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.items.length; i += 1) {\n                    const item = this.items[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    item.style.transform = '';\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            this.target.style.transform = 'none';\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('datasource/messages',[\n], function() {\n    'use strict';\n    \n    class Messages {\n        constructor(options) {\n            this.loadingTemplate = document.querySelector('#templates .scroller__item--loading');\n            this.messageTemplate = document.querySelector('#templates .scroller__item');\n            \n            this.url = options.url;\n            this.dataEndpoint = options.dataEndpoint;\n            this.dataUrl = `${this.url}${this.dataEndpoint}`;\n\n            this.nextItem = 0;\n\n            this.nextPageToken = null;\n        }\n\n        /**\n         * Fetch items from datasource.\n         */\n        fetch(obj) {\n            return new Promise((resolve, reject) => {\n\n                let params = obj.params;\n                if (params && typeof params === 'object') {\n                    params = Object.keys(params).map((key) => {\n                        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                    }).join('&');\n                }\n\n                const url = params ? obj.url + '?' + params : obj.url;\n\n                let xhr = new XMLHttpRequest();\n                xhr.open(obj.method || 'GET', url);\n\n                xhr.onload = () => {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        resolve(xhr.response);\n                    } else {\n                        reject(xhr.statusText);\n                    }\n                };\n\n                xhr.onerror = () => {\n                    reject(xhr.statusText);\n                };\n\n                // let params = obj.params;\n                // if (params && typeof params === 'object') {\n                //     params = Object.keys(params).map((key) => {\n                //         return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                //     }).join('&');\n                // }\n                xhr.send();\n            });\n        }\n\n        next() {\n            let options = {\n                method: 'GET',\n                url: this.dataUrl\n            };\n\n            if (this.nextPageToken) {\n                options.params = {\n                    pageToken: this.nextPageToken\n                };\n                // Object.assign(options, {\n                //     params: {\n                //         pageToken: this.nextPageToken\n                //     }\n                // });\n            }\n\n            return this.fetch(options).then((response) => {\n                let jsonResponse = JSON.parse(response);\n                this.nextPageToken = jsonResponse.pageToken;\n                return jsonResponse.messages;\n            });\n\n            // return this.fetch(options);\n        }\n\n        /**\n         * Create a loading element, all loading elements are identical\n         */\n        createLoadingElement() {\n            return this.loadingTemplate.cloneNode(true);\n        }\n\n        /**\n         * Render an item, reusing the provided div if provided\n         */\n        render(item, div) {\n            div = div || this.messageTemplate.cloneNode(true);\n\n            div.dataset.id = item.id;\n\n            div.querySelector('.card__avatar').src = `${this.url}${item.author.photoUrl}`;\n            div.querySelector('.card__title').textContent = item.author.name;\n            div.querySelector('.card__subtitle').textContent = this.timeSince(new Date(item.updated)); //item.updated.toString();\n            div.querySelector('.card__content').textContent = item.content;\n\n            return div;\n        }\n\n        timeSince(date) {\n            if (typeof date !== 'object') {\n                date = new Date(date);\n            }\n\n            let seconds = Math.floor((new Date() - date) / 1000),\n                interval = Math.floor(seconds / 31536000);\n\n            if (interval >= 1) {\n                return `${interval} year${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 2592000);\n            if (interval >= 1) {\n                return `${interval} month${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 86400);\n            if (interval >= 1) {\n                return `${interval} day${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 3600);\n            if (interval >= 1) {\n                return `${interval} hour${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 3600);\n            if (interval >= 1) {\n                return `${interval} minute${interval > 1 ? 's' : ''} ago`;\n            }\n\n            return `${interval} second${interval > 1 ? 's' : ''} ago`;\n        }\n    }\n\n    return Messages;\n});"]}