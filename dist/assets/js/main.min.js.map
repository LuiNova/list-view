{"version":3,"sources":["app.js","main.js","components/infinite-scroller-experimental.js","components/infinite-scroller-v2.js","components/infinite-scroller.js","datasource/messages.js"],"names":["requirejs","config","baseUrl","paths","app","main","init","define","InfiniteScroller","InfiniteScrollerExperimental","Messages","scroller","document","querySelector","scrollerExp","messagesSource","url","dataEndpoint","this","infiniteScroller","swipeable","infiniteScrollerExp","PHYSICAL_ITEMS","PROXIMITY_BOUNDARY","dataSource","options","_classCallCheck","physicalItems","PAGE_SIZE","pageSize","proximityBoundary","itemsCacheData","loadingItemHeight","loadingItemWidth","loadingItems","firstPhysicalItemIndex","middlePhysicalItemIndex","lastPhysicalItemIndex","firstPhysicalItem","lastPhysicalItem","firstPhysicalItemTranslateY","lastPhysicalItemTranslateY","requestInProgress","target","targetBCR","targetX","startX","currentX","translateX","draggingItem","scrollRunway","createElement","scrollRunwayEndBefore","scrollRunwayEnd","style","position","height","width","transition","appendChild","previousScrollTop","addEventListeners","count","onResize","loadItems","_createClass","key","value","_this","window","addEventListener","e","onScroll","onTouchStart","onTouchMove","onTouchEnd","loadingItem","createLoadingElement","offsetHeight","offsetWidth","removeChild","delta","scrollTop","normalizedLastItemIndex","proximityToLastPhysicalItem","dataset","translateY","normalizeFirstItemIndex","itemsSpace","approximateEmptySpace","proximityToFirstPhysicalItem","loadItemsUp","_this2","loadingHeight","i","hasLoadingItem","transform","classList","remove","nextIndexToPopulate","populateItems","slice","next","then","response","items","fromCache","currentCacheDataLength","length","add","itemIndex","hasReusableItem","item","render","calculatePhysicalItemsIndex","loadingItemTranslateY","populateItemsTop","itemBeforeFirstPhysicalItemIndex","reusableItemIndex","console","log","hasItem","itemsLength","Math","max","parseInt","_this3","contains","getBoundingClientRect","touches","pageX","willChange","requestAnimationFrame","update","threshold","abs","_this4","normalizedDragDistance","opacity","pow","isNearlyAtStart","parentNode","targetIndex","virtualItems","indexOf","splice","animateOtherItemsIntoPosition","resetTarget","startIndex","_this5","onAnimationComplete","removeEventListener","_","anchorScrollTop","firstAttachedItem","lastAttachedItem","virtualItemsCount","physicalItemsCount","loadedItems","anchorItem","anchorItemHeight","loadItemsExp","firstLoad","firstLoadItems","concat","populateItemsExp","push","scrollBoundary","scrollHeight","start","end","attachContent","pop","data","node","addItem","_this6","itemsData","loadingTemplate","messageTemplate","dataUrl","nextItem","nextPageToken","obj","Promise","resolve","reject","params","_typeof","Object","keys","map","encodeURIComponent","join","xhr","XMLHttpRequest","open","method","onload","status","statusText","onerror","send","pageToken","fetch","jsonResponse","JSON","parse","messages","cloneNode","div","id","src","author","photoUrl","textContent","name","timeSince","Date","updated","content","date","seconds","floor","interval"],"mappings":"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","file":"main.min.js","sourcesContent":["// For any third party dependencies, like jQuery, place them in the lib folder.\n\n// Configure loading modules from the lib directory,\n// except for 'app' ones, which are in a sibling\n// directory.\nrequirejs.config({\n    baseUrl: 'src/javascript',\n    paths: {\n        app: '../dist'\n    }\n});\n\n// Start loading the main app file. Put all of\n// your application logic in there.\nrequirejs(['main'], function(main) {\n    main.init();\n});","define('main', [\n    'components/infinite-scroller',\n    'components/infinite-scroller-experimental',\n    'datasource/messages'\n], function(\n    InfiniteScroller,\n    InfiniteScrollerExperimental,\n    Messages\n) {\n    'use strict';\n    \n    return {\n        init: function() {\n            const scroller = document.querySelector('#messages');\n            const scrollerExp = document.querySelector('#messages-exp');\n            const messagesSource = new Messages({\n                url: 'https://message-list.appspot.com',\n                dataEndpoint: '/messages'\n            });\n\n            if (scroller) {\n                this.infiniteScroller = new InfiniteScroller(scroller, messagesSource, {\n                    swipeable: true\n                });\n            }\n\n            if (scrollerExp) {\n                this.infiniteScrollerExp = new InfiniteScrollerExperimental(scrollerExp, messagesSource, {\n                    swipeable: true\n                });\n            }\n        }\n    };\n});","define('components/infinite-scroller-experimental',[\n], function() {\n    'use strict';\n    \n    const PHYSICAL_ITEMS = 20;\n    const PAGE_SIZE = 10;\n    const PROXIMITY_BOUNDARY = 300;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            // Options\n            this.swipeable = options.swipeable;\n            this.PHYSICAL_ITEMS = options.physicalItems || PHYSICAL_ITEMS;\n            this.PAGE_SIZE = options.pageSize || PAGE_SIZE;\n            this.PROXIMITY_BOUNDARY = options.proximityBoundary || PROXIMITY_BOUNDARY;\n            \n            // This will hold a cache of the data sent from server\n            this.itemsCacheData = [];\n\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.physicalItems = [];\n            this.firstPhysicalItemIndex = -1;\n            this.middlePhysicalItemIndex = -1;\n            this.lastPhysicalItemIndex = -1;\n            this.firstPhysicalItem = null;\n            this.lastPhysicalItem = null;\n            this.firstPhysicalItemTranslateY = 0;\n            this.lastPhysicalItemTranslateY = 0;\n\n            this.requestInProgress = false;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            // this.anchorItem = document.createElement('div');\n            // this.anchorItemHeight = 0;\n            // this.anchorItem.style.position = 'absolute';\n            // this.anchorItem.style.height = '0px';\n            // this.anchorItem.style.width = '20px';\n            // this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            this.onResize();\n            this.loadItems();\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        onResize(e) {\n            // On resize need to recalculate the translateY values for the elements\n            \n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            if (this.requestInProgress) {\n                return;\n            }\n\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            /**\n             * if delta is greater than 0 then user is scrolling down\n             */\n            if (delta > 0) {\n                \n                // might not need this\n                if (this.requestInProgress) {\n                    return;\n                }\n\n                // const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n                const normalizedLastItemIndex = this.lastPhysicalItemIndex % PHYSICAL_ITEMS;\n                const lastItemTranslateY = ++this.physicalItems[normalizedLastItemIndex].dataset.translateY;\n                // const proximityToLastPhysicalItem = lastItemTranslateY - (this.scroller.scrollTop + this.scroller.offsetHeight);\n                const proximityToLastPhysicalItem = (this.lastPhysicalItemTranslateY - (this.lastPhysicalItem.offsetHeight + 10)) - (this.scroller.scrollTop + this.scroller.offsetHeight);\n\n                // if (!this.requestInProgress && (scrollBoundary > this.virtualItems[normalizedLastItemIndex].dataset.translateY)) {\n                if (!this.requestInProgress && (proximityToLastPhysicalItem < PROXIMITY_BOUNDARY)) {\n                // if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    this.loadItems();\n                    // something where we say fill lower bottom\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n\n            } else if (delta < 0) {\n\n                if (this.requestInProgress) {\n                    return;\n                }\n                \n                // const firstItemIndex = Math.max(0, (this.firstAttachedItem - 10) % PHYSICAL_ITEMS);\n                // const firstItemIndex = Math.max(0, (this.firstAttachedItem - 10));\n                // const scrollProximity = this.scroller.scrollTop - this.virtualItems[firstItemIndex % PHYSICAL_ITEMS].dataset.translateY;\n\n                const normalizeFirstItemIndex = this.firstPhysicalItemIndex % PHYSICAL_ITEMS;\n                const firstItemTranslateY = ++this.physicalItems[normalizeFirstItemIndex].dataset.translateY;\n                // const proximityToFirstPhysicalItem = this.scroller.scrollTop - firstItemTranslateY;\n\n                const itemsSpace = this.lastPhysicalItemIndex - PHYSICAL_ITEMS + 1;\n                const approximateEmptySpace = itemsSpace * (this.loadingItemHeight + 10);\n                // console.log(approximateEmptySpace);\n                // console.log('Appriximate to fist item: ', this.scroller.scrollTop - approximateEmptySpace);\n                const proximityToFirstPhysicalItem = this.scroller.scrollTop - approximateEmptySpace;\n\n                // console.log('Anchor Height: ', this.anchorItem.offsetHeight);\n                // console.log('Scroller scrolltop: ', this.scroller.scrollTop);\n                // console.log('Distance: ', this.scroller.scrollTop - this.anchorItem.offsetHeight);\n\n                if (!this.requestInProgress && this.firstPhysicalItemIndex !== 0 && (proximityToFirstPhysicalItem < PROXIMITY_BOUNDARY)) {\n                    // console.log('First Item: ', this.firstPhysicalItemIndex);\n                    // console.log('Last Item: ', this.lastPhysicalItemIndex);\n                    // console.log('First item: ', this.physicalItems[normalizeFirstItemIndex]);\n                    // console.log('Proximity to first Item: ', proximityToFirstPhysicalItem);\n\n                    // could possibly check here instead for this.firstPhysicalItemIndex === 0\n                    this.loadItemsUp();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n                }\n            }\n        }\n\n        loadItems() {\n            // if (this.count > 15) {\n            //     return;\n            // }\n\n            this.requestInProgress = true;\n\n            let loadingHeight = this.scrollRunwayEnd;\n\n            // instead of appending 10 times, just append once\n            // let addingElems = false;\n            // const frag = document.createDocumentFragment();\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                // Experimental - Transform instead of removing elements\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingHeight}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    // addingElems = true;\n                    // frag.appendChild(loadingItem);\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                loadingHeight += this.loadingItemHeight + 10; // loadingHeight is more of loadingTranslateYValue\n                // loadingHeight += this.loadingItemHeight + 10;\n            }\n\n            // instead of appending 10 times, just append once\n            // if (addingElems) {\n            //     this.scroller.appendChild(frag);\n            // }\n\n            // this.scrollRunway.style.transform = `translate(0,${this.loadingHeight}px)`;\n\n            const nextIndexToPopulate = this.lastPhysicalItemIndex + 1;\n            // Check the cache\n            if (this.itemsCacheData[nextIndexToPopulate]) {\n                // use cache to populate items\n                this.populateItems(this.itemsCacheData.slice(nextIndexToPopulate, nextIndexToPopulate + 10), true);\n            } else {\n                // 10 items\n                this.dataSource.next().then((response) => {\n                    this.populateItems(response, false);\n                });\n            }\n        }\n\n        populateItems(items, fromCache) {\n            // console.log('Loading: ', this.loadingItems);\n\n            const currentCacheDataLength = this.itemsCacheData.length;\n            const nextIndexToPopulate = this.lastPhysicalItemIndex + 1;\n\n            let itemTranslateY = 0;\n\n            // if (fromCache) {\n            //     const normalizeLastItemIndex = this.lastPhysicalItemIndex % PHYSICAL_ITEMS;\n            //     const lastPhysicalItem = this.physicalItems[normalizeLastItemIndex];\n            //     const lastPhysicalItemTranslateY = ++lastPhysicalItem.dataset.translateY;\n            //     const lastPhysicalItemHeight = lastPhysicalItem.offsetHeight;\n            //     itemTranslateY = lastPhysicalItemTranslateY + (lastPhysicalItemHeight + 10);\n            // } else {\n            //     itemTranslateY = this.scrollRunwayEnd;\n            // }\n\n\n\n            // const normalizeLastItemIndex = this.lastPhysicalItemIndex % PHYSICAL_ITEMS;\n            // const lastPhysicalItem = this.physicalItems[normalizeLastItemIndex];\n            // let lastPhysicalItemTranslateY = 0;\n            // let lastPhysicalItemHeight = 0;\n\n            // if (lastPhysicalItem) {\n            //     lastPhysicalItemTranslateY = ++this.physicalItems[normalizeLastItemIndex].dataset.translateY;\n            //     lastPhysicalItemHeight = this.physicalItems[normalizeLastItemIndex].offsetHeight;\n            //     itemTranslateY = lastPhysicalItemTranslateY + (lastPhysicalItemHeight + 10);\n            // }\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[i]) {\n                    this.loadingItems[i].classList.add('invisible');\n                }\n\n                const itemIndex = (nextIndexToPopulate + i) % PHYSICAL_ITEMS;\n\n                // const hasItem = this.virtualItems[itemIndex] && this.virtualItems.length === PHYSICAL_ITEMS;\n                const hasReusableItem = this.physicalItems[itemIndex] && this.physicalItems.length === PHYSICAL_ITEMS;\n\n                const item = hasReusableItem ? this.dataSource.render(items[i], this.physicalItems[itemIndex]) : this.dataSource.render(items[i]);\n\n                // Set the translateY value\n                item.style.position = 'absolute';\n                // item.style.transform = `translateY(${itemTranslateY}px)`;\n                item.style.transform = `translateY(${this.lastPhysicalItemTranslateY}px)`;\n                item.style.width = '92%';\n                // We need these values to animate elements when removed\n                // item.dataset.translateY = itemTranslateY;\n                item.dataset.translateY = this.lastPhysicalItemTranslateY;\n\n                if (!hasReusableItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                // We need to show right scrollbar size\n                if (!fromCache) {\n                    this.scrollRunwayEnd += item.offsetHeight + 10; // make 10 a constant\n                }\n                // itemTranslateY += item.offsetHeight + 10;\n                this.lastPhysicalItemTranslateY += item.offsetHeight + 10;\n                \n                this.physicalItems[itemIndex] = item;\n                // this.itemsCacheData.push(items[i]);\n                this.itemsCacheData[currentCacheDataLength + i] = items[i];\n            }\n            \n            // This uses the updated physicalItemIndex props\n            this.calculatePhysicalItemsIndex(items.length);\n\n            // Update runway translate to update scrollbar\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        loadItemsUp() {\n            // if (this.firstPhysicalItemIndex === 0) {\n            //     // we have reached the top\n            //     return;\n            // }\n\n            this.requestInProgress = true;\n\n            const normalizeFirstItemIndex = this.firstPhysicalItemIndex % PHYSICAL_ITEMS;\n            let loadingItemTranslateY = ++this.physicalItems[normalizeFirstItemIndex].dataset.translateY - (this.loadingItemHeight + 10);\n\n            // for (let i = 0; i < 10; i += 1) {\n            for (let i = 9; i >= 0; i -= 1) {\n\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingItemTranslateY}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    // addingElems = true;\n                    // frag.appendChild(loadingItem);\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                loadingItemTranslateY -= (this.loadingItemHeight + 10);\n            }\n\n            this.populateItemsTop();\n        }\n\n        populateItemsTop() {\n\n            const normalizeFirstItemIndex = this.firstPhysicalItemIndex % PHYSICAL_ITEMS;\n            const firstPhysicalItemTranslateY = ++this.physicalItems[normalizeFirstItemIndex].dataset.translateY;\n            const firstPhysicalItemHeight = this.physicalItems[normalizeFirstItemIndex].offsetHeight;\n            const itemBeforeFirstPhysicalItemIndex = this.firstPhysicalItemIndex - 1;\n            // const firstPhysicalItemIndex = this.firstPhysicalItemIndex;\n\n            let itemTranslateY = firstPhysicalItemTranslateY - (firstPhysicalItemHeight + 10);\n            // const firstItemIndex = Math.max(0, (this.firstAttachedItem - 10)) - 1;\n\n            // looping backwards to grab the right data from cache, maybe look into looping forwards\n            // for readability\n            for (let i = itemBeforeFirstPhysicalItemIndex; i > itemBeforeFirstPhysicalItemIndex - 10; i -= 1) {\n            // for (let i = (this.firstPhysicalItemIndex - 10); i < this.firstPhysicalItemIndex; i += 1) {\n\n                if (this.loadingItems[i % 10]) {\n                    this.loadingItems[i % 10].classList.add('invisible');\n                }\n\n                // revisit this logic\n                // const reusableItemIndex = (this.lastPhysicalItemIndex - (PHYSICAL_ITEMS - 1 - i)) % PHYSICAL_ITEMS;\n                // const reusableItemIndex = (this.firstPhysicalItemIndex - (10 - i)) % PHYSICAL_ITEMS;\n\n                const reusableItemIndex = i % PHYSICAL_ITEMS;\n                console.log('Reusbale last index: ', this.lastPhysicalItemIndex);\n                console.log('Reusable index: ', reusableItemIndex);\n\n                // const itemIndex = (this.lastAttachedItem - (10 - 1 - i)) % PHYSICAL_ITEMS;\n                const hasItem = this.physicalItems[reusableItemIndex] && this.physicalItems.length === PHYSICAL_ITEMS;\n                const item = hasItem ? this.dataSource.render(this.itemsCacheData[i], this.physicalItems[reusableItemIndex]) : this.dataSource.render(this.itemsCacheData[i]);\n\n                item.style.position = 'absolute';\n                // item.style.transform = `translateY(${itemTranslateY}px)`;\n                item.style.transform = `translateY(${this.firstPhysicalItemTranslateY}px)`\n                item.style.width = '92%';\n                // We need these values to animate elements when removed\n                // item.dataset.translateY = itemTranslateY;\n                item.dataset.translateY = this.firstPhysicalItemTranslateY;\n\n                // this should never go inside qhen scrolling up otherwise we messed up\n                if (!hasItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                // itemTranslateY -= (item.offsetHeight + 10);\n                this.firstPhysicalItemTranslateY -= (item.offsetHeight + 10);\n                console.log('TranslateY: ', this.firstPhysicalItemTranslateY);\n                \n                this.physicalItems[reusableItemIndex] = item;\n            }\n\n            // Hmm will this work?\n            this.calculatePhysicalItemsIndex(-10);\n\n            // this.firstAttachedItem = index;\n            // this.lastAttachedItem = this.firstAttachedItem + (10 - 1);\n\n            this.requestInProgress = false;\n        }\n\n        calculatePhysicalItemsIndex(itemsLength) {\n\n            this.lastPhysicalItemIndex += itemsLength;\n            this.firstPhysicalItemIndex = Math.max(0, this.lastPhysicalItemIndex - (PHYSICAL_ITEMS - 1));\n            this.middlePhysicalItemIndex = this.firstPhysicalItemIndex + ((this.lastPhysicalItemIndex - this.firstPhysicalItemIndex + 1) / 2);\n\n            const lastPhysicalItem = this.physicalItems[this.lastPhysicalItemIndex % PHYSICAL_ITEMS];\n            const firstPhysicalItem = this.physicalItems[this.firstPhysicalItemIndex % PHYSICAL_ITEMS];\n            this.firstPhysicalItem = this.physicalItems[this.firstPhysicalItemIndex % PHYSICAL_ITEMS];\n            this.lastPhysicalItem = this.physicalItems[this.lastPhysicalItemIndex % PHYSICAL_ITEMS];\n            this.lastPhysicalItemTranslateY = parseInt(lastPhysicalItem.dataset.translateY, 10) + (lastPhysicalItem.offsetHeight + 10);\n            this.firstPhysicalItemTranslateY = parseInt(firstPhysicalItem.dataset.translateY, 10) - (firstPhysicalItem.offsetHeight + 10);\n\n            // Debug info\n            // console.log('firstPhysicalItemIndex: ', this.firstPhysicalItemIndex);\n            // console.log('middlePhysicalItemIndex: ', this.middlePhysicalItemIndex);\n            // console.log('lastPhysicalItemIndex: ', this.lastPhysicalItemIndex);\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            // this.target.style.transform = `translateX(${this.translateX}px)`;\n            // Since we are manipulating elements through translates we need to keep translateY\n            this.target.style.transform = `translate(${this.translateX}px, ${this.target.dataset.translateY}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                // const targetIndex = this.items.indexOf(this.target);\n                const targetIndex = this.virtualItems.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                // if (this.items.length < 6) {\n                //     this.loadItems();\n                // }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                // item.style.transform = '';\n                // item.style.transform = `translateY(${parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10}px)`;\n                // item.dataset.translateY\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.virtualItems.length; i += 1) {\n                const item = this.virtualItems[i];\n\n                // Move the card down then slide it up.\n                // item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.style.transform = `translateY(${item.dataset.translateY}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.virtualItems.length; i += 1) {\n                    const item = this.virtualItems[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    // item.style.transform = '';\n                    console.log('targetBCRheight: ', this.targetBCR.height);\n                    item.style.transform = `translateY(${parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10}px)`;\n                    item.dataset.translateY = parseInt(item.dataset.translateY, 10) - this.targetBCR.height - 10;\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            // this.target.style.transform = 'none';\n            this.target.style.transform = `translateY(${this.target.dataset.translateY}px)`;\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('components/infinite-scroller-v2',[\n], function() {\n    'use strict';\n    \n    const RUNWAY_ITEMS = 50;\n    const RUNWAY_ITEMS_OPPOSITE = 10;\n    const SCROLL_RUNWAY = 2000;\n    const ANIMATION_DURATION_MS = 200;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            this.anchorScrollTop = 0;\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.firstAttachedItem = 0;\n            this.lastAttachedItem = 0;\n            this.virtualItems = [];\n            this.physicalItems = [];\n\n            this.virtualItemsCount = 0;\n            this.physicalItemsCount = 0;\n\n            this.items = [];\n            this.loadedItems = 0;\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            // this.anchorItem.style.position = 'absolute';\n            this.anchorItem.style.height = '1px';\n            this.anchorItem.style.width = '1px';\n            // this.anchorItem.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            // this.onResize();\n            // this.loadItems();\n            this.loadItemsExp(false);\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        loadItems() {\n            this.requestInProgress = true;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const loadingItem = this.dataSource.createLoadingElement();\n                this.loadingItems[i] = loadingItem;\n                this.scroller.appendChild(loadingItem);\n            }\n\n            // 20 items\n            // this.dataSource.next().then((response) => {\n            //     this.populateItems(response);\n            //     return this.dataSource.next();\n            // }).then((response) => {\n            //     this.populateItems(response);\n            // });\n\n            // 10 items\n            this.dataSource.next().then((response) => {\n                this.populateItems(response);\n                return this.dataSource.next();\n            });\n        }\n\n        loadItemsExp(firstLoad) {\n            if (this.count > 15) {\n                return;\n            }\n\n            this.requestInProgress = true;\n            let loadingHeight = this.scrollRunwayEnd;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const hasLoadingItem = this.loadingItems[i];\n                const loadingItem = hasLoadingItem ? this.loadingItems[i] : this.dataSource.createLoadingElement();\n                \n                this.loadingItems[i] = loadingItem;\n\n                // Experimental - Transform instead of removing elements\n                loadingItem.style.position = 'absolute';\n                loadingItem.style.transform = `translateY(${loadingHeight}px)`;\n                loadingItem.style.width = '92%';\n                loadingItem.classList.remove('invisible');\n\n                // If loading item not in DOM then add it\n                if (!hasLoadingItem) {\n                    this.scroller.appendChild(loadingItem);\n                }\n\n                // Experimental - Transform instead of removing elements\n                loadingHeight += loadingItem.offsetHeight + 10;\n            }\n\n            // console.log('LOADING RUNWAY END: ', this.scrollRunwayEnd);\n            // this.scrollRunway.style.transform = `translate(0,${this.loadingHeight}px)`;\n\n            if (firstLoad) {\n                console.log('first load');\n                let firstLoadItems = [];\n                this.dataSource.next().then((response) => {\n                    firstLoadItems = firstLoadItems.concat(response);\n                    return this.dataSource.next();\n                }).then((response) => {\n                    firstLoadItems = firstLoadItems.concat(response);\n                    this.populateItemsExp(firstLoadItems);\n                });\n            } else {\n                // 10 items\n                this.dataSource.next().then((response) => {\n                    this.populateItemsExp(response);\n                    // return this.dataSource.next();\n                });\n            }\n        }\n\n        populateItems(items) {\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[0]) {\n                    this.scroller.removeChild(this.loadingItems[0]);\n                    this.loadingItems.splice(0, 1);\n                }\n                const item = this.dataSource.render(items[i]);\n                this.scroller.appendChild(item);\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                this.items.push(item);\n            }\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n        }\n\n        populateItemsExp(items) {\n            console.log('Hello');\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[i]) {\n                    this.loadingItems[i].classList.add('invisible');\n                }\n\n                const itemIndex = (this.firstAttachedItem + i) % 20;\n                const hasItem = this.virtualItems[itemIndex] && this.virtualItems.length === 20;\n\n                const item = hasItem ? this.dataSource.render(items[i], this.virtualItems[itemIndex]) : this.dataSource.render(items[i]);\n\n                // Experimental - Transform instead of removing elements\n                item.style.position = 'absolute';\n                item.style.transform = `translateY(${this.scrollRunwayEnd}px)`;\n                item.style.width = '92%';\n\n                if (!hasItem) {\n                    this.scroller.appendChild(item);\n                }\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                \n                this.virtualItems[itemIndex] = item;\n                this.items.push(item);\n            }\n\n            this.lastAttachedItem = this.firstAttachedItem + (items.length - 1);\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        onResize(e) {\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // Reset cahced size of items in the scroller\n            for (let i = 0; i < this.items.length; i += 1) {\n                this.items[i].height = this.items[i].width = 0;\n            }\n\n            this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            if (delta > 0) {\n                // scrolling down\n                const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n\n                if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    // this.loadItems();\n\n                    this.firstAttachedItem = this.lastAttachedItem + 1;\n\n                    this.loadItemsExp();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n            } else {\n                // scrolling up\n                // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n            }\n        }\n\n        /**\n         * Sets the range of items which should be attached and attaches those items\n         */\n        fill(start, end) {\n            this.firstAttachedItem = Math.max(0, start);\n            this.lastAttachedItem = end;\n            this.attachContent();\n        }\n\n        getLoadingItem() {\n            const loadingItem = this.loadingItems.pop();\n            if (loadingItem) {\n                return loadingItem;\n            }\n\n            return this.dataSource.createLoadingElement();\n        }\n\n        attachContent(start, end) {\n            // here some logic to go fetch items i.e. scrolling down and not more virtualItems\n            // and just loading from virtual items\n\n        }\n\n        addItem() {\n            this.items.push({\n                data: null,\n                node: null\n            });\n        }\n\n        addContent(items) {\n            this.requestInProgress = false;\n            for (let i = 0; i < items.length; i += 1) {\n                this.addItem();\n                this.items[this.loadedItems++].data = items[i];\n            }\n            this.attachContent();\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            this.target.style.transform = `translateX(${this.translateX}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.items.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                if (this.items.length < 6) {\n                    this.loadItems();\n                }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                item.style.transform = '';\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.items.length; i += 1) {\n                const item = this.items[i];\n\n                // Move the card down then slide it up.\n                item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.items.length; i += 1) {\n                    const item = this.items[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    item.style.transform = '';\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            this.target.style.transform = 'none';\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('components/infinite-scroller',[\n], function() {\n    'use strict';\n    \n    const RUNWAY_ITEMS = 50;\n    const RUNWAY_ITEMS_OPPOSITE = 10;\n    const SCROLL_RUNWAY = 2000;\n    const ANIMATION_DURATION_MS = 200;\n    const PHYSICAL_ITEMS = 20;\n\n    class InfiniteScroller {\n\n        constructor(scroller, dataSource, options) {\n            this.scroller = scroller;\n            this.dataSource = dataSource;\n\n            this.anchorScrollTop = 0;\n            this.loadingItemHeight = 0;\n            this.loadingItemWidth = 0;\n            this.loadingItems = [];\n\n            this.firstAttachedItem = 0;\n            this.lastAttachedItem = 0;\n            this.virtualItems = [];\n            this.physicalItems = [];\n\n            this.virtualItemsCount = 0;\n            this.physicalItemsCount = 0;\n\n            this.items = [];\n            this.itemsData = [];\n            this.loadedItems = 0;\n            this.requestInProgress = false;\n\n            this.swipeable = options.swipeable;\n\n            // Reference to current item\n            this.target = null;\n            this.targetBCR = null;\n            this.targetX = 0;\n            this.startX = 0;\n            this.currentX = 0;\n            this.translateX = 0;\n            this.draggingItem = false;\n\n            // Create element to manage top height\n            this.anchorItem = document.createElement('div');\n            this.anchorItemHeight = 0;\n            this.anchorItem.style.height = '0px';\n            this.anchorItem.style.width = '1px';\n            this.scroller.appendChild(this.anchorItem);\n\n            // Create element to force scroll\n            this.scrollRunway = document.createElement('div');\n            this.scrollRunwayEndBefore = 0;\n            this.scrollRunwayEnd = 0;\n            this.scrollRunway.style.position = 'absolute';\n            this.scrollRunway.style.height = '1px';\n            this.scrollRunway.style.width = '1px';\n            this.scrollRunway.style.transition = 'transform 0.2s';\n            this.scroller.appendChild(this.scrollRunway);\n\n            this.previousScrollTop = 0;\n\n            this.addEventListeners();\n\n            this.count = 0;\n\n            // this.onResize();\n            // this.loadItems();\n            this.loadItems();\n        }\n\n        addEventListeners() {\n            window.addEventListener('resize', (e) => this.onResize(e));\n            this.scroller.addEventListener('scroll', (e) => this.onScroll(e));\n\n            if (this.swipeable) {\n                this.scroller.addEventListener('touchstart', (e) => this.onTouchStart(e));\n                this.scroller.addEventListener('touchmove', (e) => this.onTouchMove(e));\n                this.scroller.addEventListener('touchend', (e) => this.onTouchEnd(e));\n            }\n        }\n\n        loadItems() {\n            if (this.count > 15) {\n                return;\n            }\n\n            this.requestInProgress = true;\n\n            // loaidng items\n            for (let i = 0; i < 10; i += 1) {\n                const loadingItem = this.dataSource.createLoadingElement();\n                this.loadingItems[i] = loadingItem;\n                this.scroller.appendChild(loadingItem);\n            }\n\n            // 10 items\n            this.dataSource.next().then((response) => {\n                this.populateItems(response);\n            });\n        }\n\n        populateItems(items) {\n            // console.log('Loading: ', this.loadingItems);\n\n            for (let i = 0; i < items.length; i += 1) {\n\n                if (this.loadingItems[0]) {\n                    this.scroller.removeChild(this.loadingItems[0]);\n                    this.loadingItems.splice(0, 1);\n                }\n                const item = this.dataSource.render(items[i]);\n                this.scroller.appendChild(item);\n\n                this.scrollRunwayEnd += item.offsetHeight + 10;\n                this.items.push(item);\n            }\n\n            this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n            this.requestInProgress = false;\n            this.count += 1;\n        }\n\n        onResize(e) {\n            const loadingItem = this.dataSource.createLoadingElement();\n            this.scroller.appendChild(loadingItem);\n            this.loadingItemHeight = loadingItem.offsetHeight;\n            this.loadingItemWidth = loadingItem.offsetWidth;\n            this.scroller.removeChild(loadingItem);\n\n            // Reset cahced size of items in the scroller\n            for (let i = 0; i < this.items.length; i += 1) {\n                this.items[i].height = this.items[i].width = 0;\n            }\n\n            this.onScroll();\n        }\n\n        /**\n         * It then updates the visible\n         * elements, requesting more items from the dataSource if we have scrolled\n         * past the end of currently available content.\n         */\n        onScroll(e) {\n            const delta = this.scroller.scrollTop - this.previousScrollTop;\n            this.previousScrollTop = this.scroller.scrollTop;\n\n            if (delta > 0) {\n                // scrolling down\n                const scrollBoundary = this.scroller.scrollTop + this.scroller.offsetHeight + 200;\n\n                if (!this.requestInProgress && (scrollBoundary > this.scroller.scrollHeight)) {\n                    // this.loadItems();\n\n                    this.firstAttachedItem = this.lastAttachedItem + 1;\n\n                    this.loadItems();\n                    // this.fill(this.anchorItem.index - RUNWAY_ITEMS, lastScreenItem.index + RUNWAY_ITEMS_OPPOSITE);\n                }\n            } else {\n                // scrolling up\n                // this.fill(this.anchorItem.index - RUNWAY_ITEMS_OPPOSITE, lastScreenItem.index + RUNWAY_ITEMS);\n            }\n        }\n\n        /**\n         * Sets the range of items which should be attached and attaches those items\n         */\n        fill(start, end) {\n            this.firstAttachedItem = Math.max(0, start);\n            this.lastAttachedItem = end;\n            this.attachContent();\n        }\n\n        getLoadingItem() {\n            const loadingItem = this.loadingItems.pop();\n            if (loadingItem) {\n                return loadingItem;\n            }\n\n            return this.dataSource.createLoadingElement();\n        }\n\n        attachContent(start, end) {\n            // here some logic to go fetch items i.e. scrolling down and not more virtualItems\n            // and just loading from virtual items\n\n        }\n\n        addItem() {\n            this.items.push({\n                data: null,\n                node: null\n            });\n        }\n\n        addContent(items) {\n            this.requestInProgress = false;\n            for (let i = 0; i < items.length; i += 1) {\n                this.addItem();\n                this.items[this.loadedItems++].data = items[i];\n            }\n            this.attachContent();\n        }\n\n        onTouchStart(e) {\n            if (this.target) {\n                return;\n            }\n\n            if (!e.target.classList.contains('scroller__item')) {\n                return;\n            }\n\n            this.target = e.target;\n            this.targetBCR = this.target.getBoundingClientRect();\n            this.startX = e.touches[0].pageX;\n            this.currentX = this.startX;\n            // this.translateX = 0;\n            this.draggingItem = true;\n\n            this.target.style.willChange = 'transform';\n\n            requestAnimationFrame(() => this.update());\n\n            // e.preventDefault();\n        }\n\n        onTouchMove(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.currentX = e.touches[0].pageX;\n        }\n\n        onTouchEnd(e) {\n            if (!this.target) {\n                return;\n            }\n\n            this.targetX = 0;\n            let translateX = this.currentX - this.startX;\n            const threshold = this.targetBCR.width * 0.35;\n\n            if (Math.abs(translateX) > threshold) {\n                this.targetX = (translateX > 0) ? this.targetBCR.width : -this.targetBCR.width;\n            }\n\n            this.draggingItem = false;\n        }\n\n        update() {\n            requestAnimationFrame(() => this.update());\n\n            if (!this.target) {\n                return;\n            }\n\n            if (this.draggingItem) {\n                this.translateX = this.currentX - this.startX;\n            } else {\n                this.translateX += (this.targetX - this.translateX) / 4;\n            }\n\n            const normalizedDragDistance = (Math.abs(this.translateX) / this.targetBCR.width);\n            const opacity = 1 - Math.pow(normalizedDragDistance, 3);\n\n            this.target.style.transform = `translateX(${this.translateX}px)`;\n            this.target.style.opacity = opacity;\n\n            // User has not finished dragging\n            if (this.draggingItem) {\n                return;\n            }\n\n            const isNearlyAtStart = (Math.abs(this.translateX) < 0.01);\n            const isNearlyInvisible = (opacity < 0.01);\n\n            if (isNearlyInvisible) {\n\n                if (!this.target || !this.target.parentNode) {\n                    return;\n                }\n\n                // Update runway (i.e. update scrollbar)\n                this.scrollRunwayEnd -= this.target.offsetHeight + 10;\n                this.scrollRunway.style.transform = `translate(0,${this.scrollRunwayEnd}px)`;\n\n                this.scroller.removeChild(this.target);\n                const targetIndex = this.items.indexOf(this.target);\n                this.items.splice(targetIndex, 1);\n\n                this.animateOtherItemsIntoPosition(targetIndex);\n\n                if (this.items.length < 6) {\n                    this.loadItems();\n                }\n\n            } else if (isNearlyAtStart) {\n                this.resetTarget();\n            }\n        }\n\n        animateOtherItemsIntoPosition(startIndex) {\n            // If removed card was the last one, there is nothing to animate.\n            // Remove the target\n            if (startIndex === this.items.length) {\n                this.resetTarget();\n                return;\n            }\n\n            const onAnimationComplete = (e) => {\n                const item = e.target;\n                item.removeEventListener('transitionend', onAnimationComplete);\n                item.style.transition = '';\n                item.style.transform = '';\n\n                this.resetTarget();\n            };\n\n            // Set up all card animations\n            for (let i = startIndex; i < this.items.length; i += 1) {\n                const item = this.items[i];\n\n                // Move the card down then slide it up.\n                item.style.transform = `translateY(${this.targetBCR.height + 10}px)`;\n                item.addEventListener('transitionend', (e) => onAnimationComplete(e));\n            }\n\n            // Now init them\n            requestAnimationFrame(_ => {\n                for (let i = startIndex; i < this.items.length; i += 1) {\n                    const item = this.items[i];\n\n                    // Move the card down then slide it up, with delay according to \"distance\"\n                    // item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i*50}ms`;\n                    item.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1)`;\n                    item.style.transform = '';\n                }\n            });\n        }\n\n        resetTarget() {\n            if (!this.target) {\n                return;\n            }\n\n            this.target.style.willChange = 'initial';\n            this.target.style.transform = 'none';\n            this.target = null;\n        }\n    }\n\n    return InfiniteScroller;\n});","define('datasource/messages',[\n], function() {\n    'use strict';\n    \n    class Messages {\n        constructor(options) {\n            this.loadingTemplate = document.querySelector('#templates .scroller__item--loading');\n            this.messageTemplate = document.querySelector('#templates .scroller__item');\n            \n            this.url = options.url;\n            this.dataEndpoint = options.dataEndpoint;\n            this.dataUrl = `${this.url}${this.dataEndpoint}`;\n\n            this.nextItem = 0;\n\n            this.nextPageToken = null;\n        }\n\n        /**\n         * Fetch items from datasource.\n         */\n        fetch(obj) {\n            return new Promise((resolve, reject) => {\n\n                let params = obj.params;\n                if (params && typeof params === 'object') {\n                    params = Object.keys(params).map((key) => {\n                        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                    }).join('&');\n                }\n\n                const url = params ? obj.url + '?' + params : obj.url;\n\n                let xhr = new XMLHttpRequest();\n                xhr.open(obj.method || 'GET', url);\n\n                xhr.onload = () => {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        resolve(xhr.response);\n                    } else {\n                        reject(xhr.statusText);\n                    }\n                };\n\n                xhr.onerror = () => {\n                    reject(xhr.statusText);\n                };\n\n                // let params = obj.params;\n                // if (params && typeof params === 'object') {\n                //     params = Object.keys(params).map((key) => {\n                //         return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                //     }).join('&');\n                // }\n                xhr.send();\n            });\n        }\n\n        next() {\n            let options = {\n                method: 'GET',\n                url: this.dataUrl\n            };\n\n            if (this.nextPageToken) {\n                options.params = {\n                    pageToken: this.nextPageToken\n                };\n                // Object.assign(options, {\n                //     params: {\n                //         pageToken: this.nextPageToken\n                //     }\n                // });\n            }\n\n            return this.fetch(options).then((response) => {\n                let jsonResponse = JSON.parse(response);\n                this.nextPageToken = jsonResponse.pageToken;\n                return jsonResponse.messages;\n            });\n\n            // return this.fetch(options);\n        }\n\n        /**\n         * Create a loading element, all loading elements are identical\n         */\n        createLoadingElement() {\n            return this.loadingTemplate.cloneNode(true);\n        }\n\n        /**\n         * Render an item, reusing the provided div if provided\n         */\n        render(item, div) {\n            div = div || this.messageTemplate.cloneNode(true);\n\n            div.dataset.id = item.id;\n\n            div.querySelector('.card__avatar').src = `${this.url}${item.author.photoUrl}`;\n            div.querySelector('.card__title').textContent = item.author.name;\n            div.querySelector('.card__subtitle').textContent = this.timeSince(new Date(item.updated)); //item.updated.toString();\n            div.querySelector('.card__content').textContent = item.content;\n\n            return div;\n        }\n\n        timeSince(date) {\n            if (typeof date !== 'object') {\n                date = new Date(date);\n            }\n\n            let seconds = Math.floor((new Date() - date) / 1000),\n                interval = Math.floor(seconds / 31536000);\n\n            if (interval >= 1) {\n                return `${interval} year${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 2592000);\n            if (interval >= 1) {\n                return `${interval} month${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 86400);\n            if (interval >= 1) {\n                return `${interval} day${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 3600);\n            if (interval >= 1) {\n                return `${interval} hour${interval > 1 ? 's' : ''} ago`;\n            }\n\n            interval = Math.floor(seconds / 3600);\n            if (interval >= 1) {\n                return `${interval} minute${interval > 1 ? 's' : ''} ago`;\n            }\n\n            return `${interval} second${interval > 1 ? 's' : ''} ago`;\n        }\n    }\n\n    return Messages;\n});"]}